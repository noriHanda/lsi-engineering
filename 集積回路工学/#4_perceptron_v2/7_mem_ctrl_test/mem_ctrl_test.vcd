$date
	Fri Jul 30 16:19:34 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 12 ! WRITE_DATA [11:0] $end
$var wire 2 " WRITE_ADDR [1:0] $end
$var wire 12 # READ_DATA2 [11:0] $end
$var wire 12 $ READ_DATA1 [11:0] $end
$var wire 2 % READ_ADDR2 [1:0] $end
$var wire 2 & READ_ADDR1 [1:0] $end
$var wire 12 ' DEBUG_OUT3 [11:0] $end
$var wire 12 ( DEBUG_OUT2 [11:0] $end
$var wire 12 ) DEBUG_OUT1 [11:0] $end
$var wire 12 * DEBUG_OUT0 [11:0] $end
$var reg 1 + CLK $end
$var reg 2 , STATE [1:0] $end
$var reg 2 - delta [1:0] $end
$var reg 2 . dw1 [1:0] $end
$var reg 2 / dw2 [1:0] $end
$var reg 1 0 s $end
$var reg 4 1 update_w1 [3:0] $end
$var reg 4 2 update_w2 [3:0] $end
$var reg 4 3 update_w3 [3:0] $end
$var reg 1 4 x1 $end
$var reg 1 5 x2 $end
$var reg 1 6 z $end
$scope module mem $end
$var wire 1 + CLK $end
$var wire 12 7 DEBUG_OUT0 [11:0] $end
$var wire 12 8 DEBUG_OUT1 [11:0] $end
$var wire 12 9 DEBUG_OUT2 [11:0] $end
$var wire 12 : DEBUG_OUT3 [11:0] $end
$var wire 12 ; READ_DATA1 [11:0] $end
$var wire 12 < READ_DATA2 [11:0] $end
$var wire 12 = WRITE_DATA [11:0] $end
$var wire 2 > WRITE_ADDR [1:0] $end
$var wire 2 ? READ_ADDR2 [1:0] $end
$var wire 2 @ READ_ADDR1 [1:0] $end
$upscope $end
$scope module mem_ctrl $end
$var wire 2 A STATE [1:0] $end
$var wire 2 B delta [1:0] $end
$var wire 2 C dw1 [1:0] $end
$var wire 2 D dw2 [1:0] $end
$var wire 1 0 s $end
$var wire 4 E update_w1 [3:0] $end
$var wire 4 F update_w2 [3:0] $end
$var wire 4 G update_w3 [3:0] $end
$var wire 1 4 x1 $end
$var wire 1 5 x2 $end
$var wire 1 6 z $end
$var wire 12 H WRITE_DATA [11:0] $end
$var wire 2 I WRITE_ADDR [1:0] $end
$var wire 2 J READ_ADDR2 [1:0] $end
$var wire 2 K READ_ADDR1 [1:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 K
b0 J
b0 I
b111 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b111 =
b0 <
b0 ;
b100001 :
b0 9
b0 8
b0 7
06
15
14
b0 3
b0 2
b0 1
10
b0 /
b0 .
b0 -
b0 ,
0+
b0 *
b0 )
b0 (
b100001 '
b0 &
b0 %
b0 $
b0 #
b0 "
b111 !
$end
#1
b111 $
b111 ;
b111 #
b111 <
b111 *
b111 7
1+
#2
b100001 #
b100001 <
b11 %
b11 ?
b11 J
b1 "
b1 >
b1 I
b1 !
b1 =
b1 H
0+
b1 ,
b1 A
16
05
04
00
#3
b1 )
b1 8
1+
#4
b1 #
b1 <
b1 %
b1 ?
b1 J
b10 "
b10 >
b10 I
b111001 !
b111001 =
b111001 H
0+
b10 ,
b10 A
b11 -
b11 B
b10 /
b10 D
b1 .
b1 C
06
#5
b111001 (
b111001 9
1+
#6
b111001 $
b111001 ;
b10 &
b10 @
b10 K
b100001 #
b100001 <
b11 %
b11 ?
b11 J
b11 "
b11 >
b11 I
b111110100101 !
b111110100101 =
b111110100101 H
0+
b11 ,
b11 A
b1111 3
b1111 G
b1010 2
b1010 F
b101 1
b101 E
b0 -
b0 B
b0 /
b0 D
b0 .
b0 C
#7
b111110100101 #
b111110100101 <
b111110100101 '
b111110100101 :
1+
#8
b10 !
b10 =
b10 H
b111 $
b111 ;
b0 &
b0 @
b0 K
b111 #
b111 <
b0 %
b0 ?
b0 J
b0 "
b0 >
b0 I
0+
b0 ,
b0 A
15
b0 3
b0 G
b0 2
b0 F
b0 1
b0 E
#9
b10 $
b10 ;
b10 #
b10 <
b10 *
b10 7
1+
#10
b111110100101 #
b111110100101 <
b11 %
b11 ?
b11 J
b1 "
b1 >
b1 I
b0 !
b0 =
b0 H
0+
b1 ,
b1 A
05
#11
b0 )
b0 8
1+
#12
b1110 !
b1110 =
b1110 H
b0 #
b0 <
b1 %
b1 ?
b1 J
b10 "
b10 >
b10 I
0+
b10 ,
b10 A
b11 /
b11 D
b10 .
b10 C
#13
b1110 (
b1110 9
1+
#14
b1110 $
b1110 ;
b10 &
b10 @
b10 K
b111110100101 #
b111110100101 <
b11 %
b11 ?
b11 J
b11 "
b11 >
b11 I
b100100111100 !
b100100111100 =
b100100111100 H
0+
b11 ,
b11 A
b1001 3
b1001 G
b11 2
b11 F
b1100 1
b1100 E
b0 /
b0 D
b0 .
b0 C
#15
b100100111100 #
b100100111100 <
b100100111100 '
b100100111100 :
1+
#16
b0 !
b0 =
b0 H
b10 $
b10 ;
b0 &
b0 @
b0 K
b10 #
b10 <
b0 %
b0 ?
b0 J
b0 "
b0 >
b0 I
0+
b0 ,
b0 A
b0 3
b0 G
b0 2
b0 F
b0 1
b0 E
#17
b0 $
b0 ;
b0 #
b0 <
b0 *
b0 7
1+
#18
b100100111100 #
b100100111100 <
b11 %
b11 ?
b11 J
b1 "
b1 >
b1 I
0+
b1 ,
b1 A
